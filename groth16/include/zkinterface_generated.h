// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ZKINTERFACE_ZKINTERFACE_H_
#define FLATBUFFERS_GENERATED_ZKINTERFACE_ZKINTERFACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
// static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
//               FLATBUFFERS_VERSION_MINOR == 5 &&
//               FLATBUFFERS_VERSION_REVISION == 9,
//              "Non-compatible flatbuffers version included");

namespace zkinterface {

struct CircuitHeader;
struct CircuitHeaderBuilder;

struct ConstraintSystem;
struct ConstraintSystemBuilder;

struct Witness;
struct WitnessBuilder;

struct Command;
struct CommandBuilder;

struct BilinearConstraint;
struct BilinearConstraintBuilder;

struct Variables;
struct VariablesBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct Root;
struct RootBuilder;

enum Message : uint8_t {
  Message_NONE = 0,
  Message_CircuitHeader = 1,
  Message_ConstraintSystem = 2,
  Message_Witness = 3,
  Message_Command = 4,
  Message_MIN = Message_NONE,
  Message_MAX = Message_Command
};

inline const Message (&EnumValuesMessage())[5] {
  static const Message values[] = {
    Message_NONE,
    Message_CircuitHeader,
    Message_ConstraintSystem,
    Message_Witness,
    Message_Command
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[6] = {
    "NONE",
    "CircuitHeader",
    "ConstraintSystem",
    "Witness",
    "Command",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message_NONE, Message_Command)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<zkinterface::CircuitHeader> {
  static const Message enum_value = Message_CircuitHeader;
};

template<> struct MessageTraits<zkinterface::ConstraintSystem> {
  static const Message enum_value = Message_ConstraintSystem;
};

template<> struct MessageTraits<zkinterface::Witness> {
  static const Message enum_value = Message_Witness;
};

template<> struct MessageTraits<zkinterface::Command> {
  static const Message enum_value = Message_Command;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

/// A description of a circuit or sub-circuit.
/// This can be a complete circuit ready for proving,
/// or a part of a circuit being built.
struct CircuitHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircuitHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE_VARIABLES = 4,
    VT_FREE_VARIABLE_ID = 6,
    VT_FIELD_MAXIMUM = 8,
    VT_CONFIGURATION = 10
  };
  /// Instance variables. This is also called public inputs to the circuit.
  ///
  /// - Variables are allocated by the sender of this message.
  /// - The same structure must be provided for R1CS and witness generations.
  /// - Values may be omitted in some contexts, such as in a preprocessing phase.
  /// - During witness generation, variables must be assigned values.
  /// - In the particular context of a gadget call, `instance_variables` holds the inputs
  ///   to the gadget, i.e. variables allocated by the caller that the gadget can
  ///   refer to. In the context of a gadget response, it holds the outputs of the gadget,
  ///   i.e. variables allocated by the gadget that the caller can refer to.
  const zkinterface::Variables *instance_variables() const {
    return GetPointer<const zkinterface::Variables *>(VT_INSTANCE_VARIABLES);
  }
  /// A variable ID greater than all IDs allocated by the sender of this message.
  /// The recipient of this message can allocate new IDs >= free_variable_id.
  uint64_t free_variable_id() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID, 0);
  }
  /// The largest element of the finite field used by the current system.
  /// A canonical little-endian representation of the field order minus one.
  /// See `Variables.values` below.
  const ::flatbuffers::Vector<uint8_t> *field_maximum() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_FIELD_MAXIMUM);
  }
  /// Optional: Any custom parameter that may influence the circuit construction.
  ///
  /// Example: function_name, if a gadget supports multiple function variants.
  /// Example: the depth of a Merkle tree.
  /// Counter-example: a Merkle path is not config and belongs in `instance_variables.info`.
  const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *configuration() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *>(VT_CONFIGURATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCE_VARIABLES) &&
           verifier.VerifyTable(instance_variables()) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID, 8) &&
           VerifyOffset(verifier, VT_FIELD_MAXIMUM) &&
           verifier.VerifyVector(field_maximum()) &&
           VerifyOffset(verifier, VT_CONFIGURATION) &&
           verifier.VerifyVector(configuration()) &&
           verifier.VerifyVectorOfTables(configuration()) &&
           verifier.EndTable();
  }
};

struct CircuitHeaderBuilder {
  typedef CircuitHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instance_variables(::flatbuffers::Offset<zkinterface::Variables> instance_variables) {
    fbb_.AddOffset(CircuitHeader::VT_INSTANCE_VARIABLES, instance_variables);
  }
  void add_free_variable_id(uint64_t free_variable_id) {
    fbb_.AddElement<uint64_t>(CircuitHeader::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  void add_field_maximum(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> field_maximum) {
    fbb_.AddOffset(CircuitHeader::VT_FIELD_MAXIMUM, field_maximum);
  }
  void add_configuration(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> configuration) {
    fbb_.AddOffset(CircuitHeader::VT_CONFIGURATION, configuration);
  }
  explicit CircuitHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircuitHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircuitHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CircuitHeader> CreateCircuitHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<zkinterface::Variables> instance_variables = 0,
    uint64_t free_variable_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> field_maximum = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> configuration = 0) {
  CircuitHeaderBuilder builder_(_fbb);
  builder_.add_free_variable_id(free_variable_id);
  builder_.add_configuration(configuration);
  builder_.add_field_maximum(field_maximum);
  builder_.add_instance_variables(instance_variables);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CircuitHeader> CreateCircuitHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<zkinterface::Variables> instance_variables = 0,
    uint64_t free_variable_id = 0,
    const std::vector<uint8_t> *field_maximum = nullptr,
    const std::vector<::flatbuffers::Offset<zkinterface::KeyValue>> *configuration = nullptr) {
  auto field_maximum__ = field_maximum ? _fbb.CreateVector<uint8_t>(*field_maximum) : 0;
  auto configuration__ = configuration ? _fbb.CreateVector<::flatbuffers::Offset<zkinterface::KeyValue>>(*configuration) : 0;
  return zkinterface::CreateCircuitHeader(
      _fbb,
      instance_variables,
      free_variable_id,
      field_maximum__,
      configuration__);
}

/// ConstraintSystem represents constraints to be added to the constraint system.
///
/// Multiple such messages are equivalent to the concatenation of `constraints` arrays.
struct ConstraintSystem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstraintSystemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINTS = 4,
    VT_INFO = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::BilinearConstraint>> *constraints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::BilinearConstraint>> *>(VT_CONSTRAINTS);
  }
  /// Optional: Any complementary info that may be useful.
  ///
  /// Example: human-readable descriptions.
  /// Example: custom hints to an optimizer or analyzer.
  const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *>(VT_INFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyVector(constraints()) &&
           verifier.VerifyVectorOfTables(constraints()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           verifier.EndTable();
  }
};

struct ConstraintSystemBuilder {
  typedef ConstraintSystem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_constraints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::BilinearConstraint>>> constraints) {
    fbb_.AddOffset(ConstraintSystem::VT_CONSTRAINTS, constraints);
  }
  void add_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> info) {
    fbb_.AddOffset(ConstraintSystem::VT_INFO, info);
  }
  explicit ConstraintSystemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstraintSystem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstraintSystem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstraintSystem> CreateConstraintSystem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::BilinearConstraint>>> constraints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> info = 0) {
  ConstraintSystemBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_constraints(constraints);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConstraintSystem> CreateConstraintSystemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<zkinterface::BilinearConstraint>> *constraints = nullptr,
    const std::vector<::flatbuffers::Offset<zkinterface::KeyValue>> *info = nullptr) {
  auto constraints__ = constraints ? _fbb.CreateVector<::flatbuffers::Offset<zkinterface::BilinearConstraint>>(*constraints) : 0;
  auto info__ = info ? _fbb.CreateVector<::flatbuffers::Offset<zkinterface::KeyValue>>(*info) : 0;
  return zkinterface::CreateConstraintSystem(
      _fbb,
      constraints__,
      info__);
}

/// Witness represents an assignment of values to variables.
///
/// - Does not include variables already given in `CircuitHeader.instance_variables`.
/// - Does not include the constant one variable.
/// - Multiple such messages are equivalent to the concatenation of `Variables` arrays.
struct Witness FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WitnessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSIGNED_VARIABLES = 4
  };
  const zkinterface::Variables *assigned_variables() const {
    return GetPointer<const zkinterface::Variables *>(VT_ASSIGNED_VARIABLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSIGNED_VARIABLES) &&
           verifier.VerifyTable(assigned_variables()) &&
           verifier.EndTable();
  }
};

struct WitnessBuilder {
  typedef Witness Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_assigned_variables(::flatbuffers::Offset<zkinterface::Variables> assigned_variables) {
    fbb_.AddOffset(Witness::VT_ASSIGNED_VARIABLES, assigned_variables);
  }
  explicit WitnessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Witness> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Witness>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Witness> CreateWitness(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<zkinterface::Variables> assigned_variables = 0) {
  WitnessBuilder builder_(_fbb);
  builder_.add_assigned_variables(assigned_variables);
  return builder_.Finish();
}

/// Optional: Command messages can be used to request actions from the receiver. This makes it
/// possible to write code that works in different environments. Commands and parameters
/// can be passed over the same byte stream as other messages; if so Command must be the first
/// message. This reduces the need for environment-specific methods (it can replace CLI --flags, etc).
struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINTS_GENERATION = 4,
    VT_WITNESS_GENERATION = 6,
    VT_PARAMETERS = 8
  };
  /// For gadget flows.
  /// Request the generation of a constraint system (or part thereof).
  /// If true, this must be followed by a CircuitHeader.
  /// The response must be another CircuitHeader message with a greater `free_variable_id`
  /// followed by one or more ConstraintSystem messages.
  bool constraints_generation() const {
    return GetField<uint8_t>(VT_CONSTRAINTS_GENERATION, 0) != 0;
  }
  /// For gadget flows.
  /// Request the generation of a witness (or part thereof).
  /// If true, this must be followed by a CircuitHeader, and the `instance_variables`
  /// variables must contain input values.
  /// The response must be another CircuitHeader message, with a greater `free_variable_id`,
  /// with output values in `instance_variables`, followed by one or more `Witness` messages.
  bool witness_generation() const {
    return GetField<uint8_t>(VT_WITNESS_GENERATION, 0) != 0;
  }
  /// Optional: Any complementary parameter that may be useful.
  const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *>(VT_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONSTRAINTS_GENERATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_WITNESS_GENERATION, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           verifier.EndTable();
  }
};

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_constraints_generation(bool constraints_generation) {
    fbb_.AddElement<uint8_t>(Command::VT_CONSTRAINTS_GENERATION, static_cast<uint8_t>(constraints_generation), 0);
  }
  void add_witness_generation(bool witness_generation) {
    fbb_.AddElement<uint8_t>(Command::VT_WITNESS_GENERATION, static_cast<uint8_t>(witness_generation), 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> parameters) {
    fbb_.AddOffset(Command::VT_PARAMETERS, parameters);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool constraints_generation = false,
    bool witness_generation = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> parameters = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_witness_generation(witness_generation);
  builder_.add_constraints_generation(constraints_generation);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Command> CreateCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool constraints_generation = false,
    bool witness_generation = false,
    const std::vector<::flatbuffers::Offset<zkinterface::KeyValue>> *parameters = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<zkinterface::KeyValue>>(*parameters) : 0;
  return zkinterface::CreateCommand(
      _fbb,
      constraints_generation,
      witness_generation,
      parameters__);
}

/// A single R1CS constraint between variables.
///
/// - Represents the linear combinations of variables A, B, C such that:
///       (A) * (B) = (C)
/// - A linear combination is given as a sequence of (variable ID, coefficient).
struct BilinearConstraint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BilinearConstraintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINEAR_COMBINATION_A = 4,
    VT_LINEAR_COMBINATION_B = 6,
    VT_LINEAR_COMBINATION_C = 8
  };
  const zkinterface::Variables *linear_combination_a() const {
    return GetPointer<const zkinterface::Variables *>(VT_LINEAR_COMBINATION_A);
  }
  const zkinterface::Variables *linear_combination_b() const {
    return GetPointer<const zkinterface::Variables *>(VT_LINEAR_COMBINATION_B);
  }
  const zkinterface::Variables *linear_combination_c() const {
    return GetPointer<const zkinterface::Variables *>(VT_LINEAR_COMBINATION_C);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LINEAR_COMBINATION_A) &&
           verifier.VerifyTable(linear_combination_a()) &&
           VerifyOffset(verifier, VT_LINEAR_COMBINATION_B) &&
           verifier.VerifyTable(linear_combination_b()) &&
           VerifyOffset(verifier, VT_LINEAR_COMBINATION_C) &&
           verifier.VerifyTable(linear_combination_c()) &&
           verifier.EndTable();
  }
};

struct BilinearConstraintBuilder {
  typedef BilinearConstraint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_linear_combination_a(::flatbuffers::Offset<zkinterface::Variables> linear_combination_a) {
    fbb_.AddOffset(BilinearConstraint::VT_LINEAR_COMBINATION_A, linear_combination_a);
  }
  void add_linear_combination_b(::flatbuffers::Offset<zkinterface::Variables> linear_combination_b) {
    fbb_.AddOffset(BilinearConstraint::VT_LINEAR_COMBINATION_B, linear_combination_b);
  }
  void add_linear_combination_c(::flatbuffers::Offset<zkinterface::Variables> linear_combination_c) {
    fbb_.AddOffset(BilinearConstraint::VT_LINEAR_COMBINATION_C, linear_combination_c);
  }
  explicit BilinearConstraintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BilinearConstraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BilinearConstraint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BilinearConstraint> CreateBilinearConstraint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<zkinterface::Variables> linear_combination_a = 0,
    ::flatbuffers::Offset<zkinterface::Variables> linear_combination_b = 0,
    ::flatbuffers::Offset<zkinterface::Variables> linear_combination_c = 0) {
  BilinearConstraintBuilder builder_(_fbb);
  builder_.add_linear_combination_c(linear_combination_c);
  builder_.add_linear_combination_b(linear_combination_b);
  builder_.add_linear_combination_a(linear_combination_a);
  return builder_.Finish();
}

/// A description of multiple variables.
///
/// - Each variable is identified by a numerical ID.
/// - Each variable can be assigned a concrete value.
/// - In `CircuitHeader.instance_variables`, the IDs indicate which variables are
///   meant to be shared as inputs or outputs of a sub-circuit.
/// - During witness generation, the values form the assignment to the variables.
/// - In `BilinearConstraint` linear combinations, the values are the coefficients
///   applied to variables in a linear combination.
struct Variables FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VariablesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_IDS = 4,
    VT_VALUES = 6,
    VT_INFO = 8
  };
  /// The IDs of the variables.
  ///
  /// - IDs must be unique within a constraint system.
  /// - The ID 0 always represents the constant variable one.
  const ::flatbuffers::Vector<uint64_t> *variable_ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_VARIABLE_IDS);
  }
  /// Optional: values assigned to variables.
  ///
  /// - Values are finite field elements as defined by `header.field_maximum`.
  /// - Elements are represented in canonical little-endian form.
  /// - Elements appear in the same order as variable_ids.
  /// - Multiple elements are concatenated in a single byte array.
  /// - The element representation may be truncated and its size shorter
  ///   than `header.field_maximum`. Truncated bytes are treated as zeros.
  /// - The size of an element representation is determined by:
  ///
  ///     element size = values.length / variable_ids.length
  const ::flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  /// Optional: Any complementary info that may be useful to the recipient.
  ///
  /// Example: human-readable names.
  /// Example: custom variable typing information (`is_bit`, ...).
  /// Example: a Merkle authentication path in some custom format.
  const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *info() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>> *>(VT_INFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE_IDS) &&
           verifier.VerifyVector(variable_ids()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           verifier.EndTable();
  }
};

struct VariablesBuilder {
  typedef Variables Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_variable_ids(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> variable_ids) {
    fbb_.AddOffset(Variables::VT_VARIABLE_IDS, variable_ids);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(Variables::VT_VALUES, values);
  }
  void add_info(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> info) {
    fbb_.AddOffset(Variables::VT_INFO, info);
  }
  explicit VariablesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Variables> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Variables>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Variables> CreateVariables(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> variable_ids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<zkinterface::KeyValue>>> info = 0) {
  VariablesBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_values(values);
  builder_.add_variable_ids(variable_ids);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Variables> CreateVariablesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *variable_ids = nullptr,
    const std::vector<uint8_t> *values = nullptr,
    const std::vector<::flatbuffers::Offset<zkinterface::KeyValue>> *info = nullptr) {
  auto variable_ids__ = variable_ids ? _fbb.CreateVector<uint64_t>(*variable_ids) : 0;
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  auto info__ = info ? _fbb.CreateVector<::flatbuffers::Offset<zkinterface::KeyValue>>(*info) : 0;
  return zkinterface::CreateVariables(
      _fbb,
      variable_ids__,
      values__,
      info__);
}

/// Generic key-value for custom attributes.
/// The key must be a string.
/// The value can be one of several types.
struct KeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_DATA = 6,
    VT_TEXT = 8,
    VT_NUMBER = 10
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  int64_t number() const {
    return GetField<int64_t>(VT_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<int64_t>(verifier, VT_NUMBER, 8) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(KeyValue::VT_DATA, data);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(KeyValue::VT_TEXT, text);
  }
  void add_number(int64_t number) {
    fbb_.AddElement<int64_t>(KeyValue::VT_NUMBER, number, 0);
  }
  explicit KeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    int64_t number = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_text(text);
  builder_.add_data(data);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *data = nullptr,
    const char *text = nullptr,
    int64_t number = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return zkinterface::CreateKeyValue(
      _fbb,
      key__,
      data__,
      text__,
      number);
}

struct Root FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  zkinterface::Message message_type() const {
    return static_cast<zkinterface::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const zkinterface::CircuitHeader *message_as_CircuitHeader() const {
    return message_type() == zkinterface::Message_CircuitHeader ? static_cast<const zkinterface::CircuitHeader *>(message()) : nullptr;
  }
  const zkinterface::ConstraintSystem *message_as_ConstraintSystem() const {
    return message_type() == zkinterface::Message_ConstraintSystem ? static_cast<const zkinterface::ConstraintSystem *>(message()) : nullptr;
  }
  const zkinterface::Witness *message_as_Witness() const {
    return message_type() == zkinterface::Message_Witness ? static_cast<const zkinterface::Witness *>(message()) : nullptr;
  }
  const zkinterface::Command *message_as_Command() const {
    return message_type() == zkinterface::Message_Command ? static_cast<const zkinterface::Command *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const zkinterface::CircuitHeader *Root::message_as<zkinterface::CircuitHeader>() const {
  return message_as_CircuitHeader();
}

template<> inline const zkinterface::ConstraintSystem *Root::message_as<zkinterface::ConstraintSystem>() const {
  return message_as_ConstraintSystem();
}

template<> inline const zkinterface::Witness *Root::message_as<zkinterface::Witness>() const {
  return message_as_Witness();
}

template<> inline const zkinterface::Command *Root::message_as<zkinterface::Command>() const {
  return message_as_Command();
}

struct RootBuilder {
  typedef Root Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(zkinterface::Message message_type) {
    fbb_.AddElement<uint8_t>(Root::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Root::VT_MESSAGE, message);
  }
  explicit RootBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Root> CreateRoot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    zkinterface::Message message_type = zkinterface::Message_NONE,
    ::flatbuffers::Offset<void> message = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_CircuitHeader: {
      auto ptr = reinterpret_cast<const zkinterface::CircuitHeader *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ConstraintSystem: {
      auto ptr = reinterpret_cast<const zkinterface::ConstraintSystem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Witness: {
      auto ptr = reinterpret_cast<const zkinterface::Witness *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Command: {
      auto ptr = reinterpret_cast<const zkinterface::Command *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const zkinterface::Root *GetRoot(const void *buf) {
  return ::flatbuffers::GetRoot<zkinterface::Root>(buf);
}

inline const zkinterface::Root *GetSizePrefixedRoot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<zkinterface::Root>(buf);
}

inline const char *RootIdentifier() {
  return "zkif";
}

inline bool RootBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RootIdentifier());
}

inline bool SizePrefixedRootBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RootIdentifier(), true);
}

inline bool VerifyRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<zkinterface::Root>(RootIdentifier());
}

inline bool VerifySizePrefixedRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<zkinterface::Root>(RootIdentifier());
}

inline const char *RootExtension() {
  return "zkif";
}

inline void FinishRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zkinterface::Root> root) {
  fbb.Finish(root, RootIdentifier());
}

inline void FinishSizePrefixedRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<zkinterface::Root> root) {
  fbb.FinishSizePrefixed(root, RootIdentifier());
}

}  // namespace zkinterface

#endif  // FLATBUFFERS_GENERATED_ZKINTERFACE_ZKINTERFACE_H_
